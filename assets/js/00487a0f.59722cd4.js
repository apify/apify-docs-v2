"use strict";(self.webpackChunkapify_docs_v2=self.webpackChunkapify_docs_v2||[]).push([[725],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>m});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),p=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(r),h=a,m=c["".concat(s,".").concat(h)]||c[h]||d[h]||o;return r?n.createElement(m,i(i({ref:t},u),{},{components:r})):n.createElement(m,i({ref:t},u))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=r[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},67884:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>p,toc:()=>c});var n=r(87462),a=r(63366),o=(r(67294),r(3905)),i=["components"],l={title:"Input schema",description:"Learn how to generate a user interface on the platform for your actor's input with a single file - the INPUT_SCHEMA.json file.",sidebar_position:2,slug:"/deploying-your-code/input-schema"},s="[](#input-schema) Input schema",p={unversionedId:"deploying_your_code/input_schema",id:"deploying_your_code/input_schema",title:"Input schema",description:"Learn how to generate a user interface on the platform for your actor's input with a single file - the INPUT_SCHEMA.json file.",source:"@site/sources/academy/deploying_your_code/input_schema.md",sourceDirName:"deploying_your_code",slug:"/deploying-your-code/input-schema",permalink:"/academy/deploying-your-code/input-schema",draft:!1,tags:[],version:"current",lastUpdatedBy:"Martin Ad\xe1mek",lastUpdatedAt:1671793405,formattedLastUpdatedAt:"Dec 23, 2022",sidebarPosition:2,frontMatter:{title:"Input schema",description:"Learn how to generate a user interface on the platform for your actor's input with a single file - the INPUT_SCHEMA.json file.",sidebar_position:2,slug:"/deploying-your-code/input-schema"},sidebar:"defaultSidebar",previous:{title:"Inputs & outputs",permalink:"/academy/deploying-your-code/inputs-outputs"},next:{title:"Dockerfile",permalink:"/academy/deploying-your-code/docker-file"}},u={},c=[{value:" Schema title &amp; description",id:"-schema-title--description",level:2},{value:" Properties",id:"-properties",level:2},{value:" Property types &amp; editor types",id:"-property-types--editor-types",level:2},{value:" Required fields",id:"-required-fields",level:2},{value:" Final thoughts",id:"-final-thoughts",level:2},{value:" Next up",id:"-next-up",level:2}],d={toc:c};function h(e){var t=e.components,l=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"-input-schema"},(0,o.kt)("a",{parentName:"h1",href:"#input-schema",target:null,rel:null})," Input schema"),(0,o.kt)("p",null,"Though writing an ",(0,o.kt)("a",{parentName:"p",href:"https://docs.apify.com/actors/development/input-schema",target:"_blank",rel:"noopener"},"input schema")," for an actor is not a required step, it is most definitely an ideal one. The Apify platform will read the ",(0,o.kt)("strong",{parentName:"p"},"INPUT_SCHEMA.json")," file within the root of your project and generate a user interface for entering input into your actor, which makes it significantly easier for non-developers (and even developers) to configure and understand the inputs your actor can receive. Because of this, we'll be writing an input schema for our example actor."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Without an input schema, the users of our actor will have to provide the input in JSON format, which can be problematic for those who are not familiar with JSON.")),(0,o.kt)("h2",{id:"-schema-title--description"},(0,o.kt)("a",{parentName:"h2",href:"#title-and-description",target:null,rel:null})," Schema title & description"),(0,o.kt)("p",null,"In the root of our project, we'll create a file named ",(0,o.kt)("strong",{parentName:"p"},"INPUT_SCHEMA.json")," and start writing the first part of the schema."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "title": "Adding actor input",\n    "description": "Add all values in list of numbers with an arbitrary length.",\n    "type": "object",\n    "schemaVersion": 1,\n}\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"title")," and ",(0,o.kt)("strong",{parentName:"p"},"description")," simply describe what the input schema is for, and a bit about what the actor itself does."),(0,o.kt)("h2",{id:"-properties"},(0,o.kt)("a",{parentName:"h2",href:"#properties",target:null,rel:null})," Properties"),(0,o.kt)("p",null,"In order to define all of the properties our actor is expecting, we must include them within an object with a key of ",(0,o.kt)("strong",{parentName:"p"},"properties"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "title": "Adding actor input",\n    "description": "Add all values in list of numbers with an arbitrary length.",\n    "type": "object",\n    "schemaVersion": 1,\n    "properties": {\n        "numbers": {\n            "title": "Number list",\n            "description": "The list of numbers to add up.",\n        }\n    },\n}\n')),(0,o.kt)("p",null,"Each property's key corresponds to the name we're expecting within our code, while the ",(0,o.kt)("strong",{parentName:"p"},"title")," and ",(0,o.kt)("strong",{parentName:"p"},"description")," are what the user will see when configuring input on the platform."),(0,o.kt)("h2",{id:"-property-types--editor-types"},(0,o.kt)("a",{parentName:"h2",href:"#property-types",target:null,rel:null})," Property types & editor types"),(0,o.kt)("p",null,"Within our new ",(0,o.kt)("strong",{parentName:"p"},"numbers")," property, there are two more fields we must specify. Firstly, we must let the platform know that we're expecting an array of numbers with the ",(0,o.kt)("strong",{parentName:"p"},"type")," field. Then, we should also instruct Apify on which UI component to render for this input property. In our case, we have an array of numbers, which means we should use the ",(0,o.kt)("strong",{parentName:"p"},"json")," editor type that we discovered in the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.apify.com/actors/development/input-schema#array",target:"_blank",rel:"noopener"},'"array" section')," of the input schema documentation. We could also use ",(0,o.kt)("strong",{parentName:"p"},"stringList"),", but then we'd have to parse out the numbers from the strings."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "title": "Adding actor input",\n    "description": "Add all values in list of numbers with an arbitrary length.",\n    "type": "object",\n    "schemaVersion": 1,\n    "properties": {\n        "numbers": {\n            "title": "Number list",\n            "description": "The list of numbers to add up.",\n            "type": "array",\n            "editor": "json"\n        }\n    },\n}\n')),(0,o.kt)("h2",{id:"-required-fields"},(0,o.kt)("a",{parentName:"h2",href:"#required-fields",target:null,rel:null})," Required fields"),(0,o.kt)("p",null,"The great thing about building an input schema is that it will automatically validate your inputs based on their type, maximum value, minimum value, etc. Sometimes, you want to ensure that the user will always provide input for certain fields, as they are crucial to the actor's run. This can be done by using the ",(0,o.kt)("strong",{parentName:"p"},"required")," field, and passing in the names of the fields you'd like to require."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "title": "Adding actor input",\n    "description": "Add all values in list of numbers with an arbitrary length.",\n    "type": "object",\n    "schemaVersion": 1,\n    "properties": {\n        "numbers": {\n            "title": "Number list",\n            "description": "The list of numbers to add up.",\n            "type": "array",\n            "editor": "json"\n        }\n    },\n    "required": ["numbers"]\n}\n')),(0,o.kt)("p",null,"For our case, we've made the ",(0,o.kt)("strong",{parentName:"p"},"numbers")," field required, as it is crucial to our actor's run."),(0,o.kt)("h2",{id:"-final-thoughts"},(0,o.kt)("a",{parentName:"h2",href:"#final-thoughts",target:null,rel:null})," Final thoughts"),(0,o.kt)("p",null,"Here is what the output schema we wrote will render on the platform:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Rendered UI from input schema",src:r(11257).Z,width:"1542",height:"800"})),(0,o.kt)("p",null,"Later on, we'll be building more complex input schemas, as well as discussing how to write quality input schemas that allow the user to easily understand the actor and not become overwhelmed."),(0,o.kt)("p",null,"It is not expected to memorize all of the fields that properties can take, or the different editor types available, which is why it's always good to reference the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.apify.com/actors/development/input-schema",target:"_blank",rel:"noopener"},"input schema documentation")," when writing a schema."),(0,o.kt)("h2",{id:"-next-up"},(0,o.kt)("a",{parentName:"h2",href:"#next",target:null,rel:null})," Next up"),(0,o.kt)("p",null,"In the ",(0,o.kt)("a",{parentName:"p",href:"/academy/deploying-your-code/docker-file",target:null,rel:null},"next lesson"),", we'll be learning about a very important file that is required for our project to run on the Apify platform - the Dockerfile."))}h.isMDXComponent=!0},11257:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/rendered-ui-42572509f4bce04e4d7d0a9c7b7db190.webp"}}]);